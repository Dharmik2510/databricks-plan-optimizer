import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { AppLoggerService } from './app-logger.service';

/**
 * Workflow metrics aggregation and monitoring service
 *
 * Provides:
 * - Real-time workflow execution metrics
 * - Historical trend analysis
 * - Performance monitoring
 * - Error rate tracking
 * - Cost estimation
 */
@Injectable()
export class WorkflowMetricsService {
  constructor(
    private readonly logger: AppLoggerService,
    private readonly prisma: PrismaService,
  ) {}

  /**
   * Get workflow execution metrics for a time period
   */
  async getWorkflowMetrics(options: {
    workflowName?: string;
    userId?: string;
    analysisId?: string;
    hours?: number;
    since?: Date;
    until?: Date;
  }): Promise<{
    totalRuns: number;
    completedRuns: number;
    failedRuns: number;
    runningRuns: number;
    avgDurationMs: number | null;
    p50DurationMs: number | null;
    p95DurationMs: number | null;
    p99DurationMs: number | null;
    errorRate: number;
    successRate: number;
  }> {
    // Determine time range
    const since = options.since || new Date(Date.now() - (options.hours || 24) * 60 * 60 * 1000);
    const until = options.until || new Date();

    // Build where clause
    const where: any = {
      startedAt: {
        gte: since,
        lte: until,
      },
    };

    if (options.workflowName) {
      where.workflowName = options.workflowName;
    }

    if (options.userId) {
      where.userId = options.userId;
    }

    if (options.analysisId) {
      where.analysisId = options.analysisId;
    }

    // Get workflow runs
    const runs = await this.prisma.workflowRun.findMany({
      where,
      select: {
        status: true,
        durationMs: true,
      },
    });

    const totalRuns = runs.length;
    const completedRuns = runs.filter(r => r.status === 'completed').length;
    const failedRuns = runs.filter(r => r.status === 'failed').length;
    const runningRuns = runs.filter(r => r.status === 'running').length;

    // Calculate duration percentiles
    const completedDurations = runs
      .filter(r => r.status === 'completed' && r.durationMs !== null)
      .map(r => r.durationMs as number)
      .sort((a, b) => a - b);

    const avgDurationMs = completedDurations.length > 0
      ? completedDurations.reduce((a, b) => a + b, 0) / completedDurations.length
      : null;

    const p50DurationMs = completedDurations.length > 0
      ? completedDurations[Math.floor(completedDurations.length * 0.5)]
      : null;

    const p95DurationMs = completedDurations.length > 0
      ? completedDurations[Math.floor(completedDurations.length * 0.95)]
      : null;

    const p99DurationMs = completedDurations.length > 0
      ? completedDurations[Math.floor(completedDurations.length * 0.99)]
      : null;

    const errorRate = totalRuns > 0 ? (failedRuns / totalRuns) * 100 : 0;
    const successRate = totalRuns > 0 ? (completedRuns / totalRuns) * 100 : 0;

    return {
      totalRuns,
      completedRuns,
      failedRuns,
      runningRuns,
      avgDurationMs,
      p50DurationMs,
      p95DurationMs,
      p99DurationMs,
      errorRate,
      successRate,
    };
  }

  /**
   * Get node-level metrics for a workflow
   */
  async getNodeMetrics(options: {
    workflowRunId?: string;
    workflowName?: string;
    nodeType?: string;
    hours?: number;
  }): Promise<Array<{
    nodeName: string;
    nodeType: string;
    totalExecutions: number;
    successfulExecutions: number;
    failedExecutions: number;
    avgDurationMs: number | null;
    errorRate: number;
  }>> {
    const since = new Date(Date.now() - (options.hours || 24) * 60 * 60 * 1000);

    // Build where clause for workflow runs
    const runWhere: any = {
      startedAt: { gte: since },
    };

    if (options.workflowName) {
      runWhere.workflowName = options.workflowName;
    }

    if (options.workflowRunId) {
      runWhere.id = options.workflowRunId;
    }

    // Get workflow events
    const events = await this.prisma.workflowEvent.findMany({
      where: {
        workflowRun: runWhere,
        ...(options.nodeType && { nodeType: options.nodeType }),
      },
      select: {
        nodeName: true,
        nodeType: true,
        eventType: true,
        durationMs: true,
      },
    });

    // Group by node name
    const nodeGroups = new Map<string, typeof events>();
    for (const event of events) {
      const key = `${event.nodeName}:${event.nodeType}`;
      if (!nodeGroups.has(key)) {
        nodeGroups.set(key, []);
      }
      nodeGroups.get(key)!.push(event);
    }

    // Calculate metrics for each node
    const metrics = [];
    for (const [key, nodeEvents] of nodeGroups.entries()) {
      const [nodeName, nodeType] = key.split(':');

      const totalExecutions = nodeEvents.filter(e =>
        e.eventType === 'node_completed' || e.eventType === 'node_failed'
      ).length;

      const successfulExecutions = nodeEvents.filter(e =>
        e.eventType === 'node_completed'
      ).length;

      const failedExecutions = nodeEvents.filter(e =>
        e.eventType === 'node_failed'
      ).length;

      const durations = nodeEvents
        .filter(e => e.durationMs !== null)
        .map(e => e.durationMs as number);

      const avgDurationMs = durations.length > 0
        ? durations.reduce((a, b) => a + b, 0) / durations.length
        : null;

      const errorRate = totalExecutions > 0
        ? (failedExecutions / totalExecutions) * 100
        : 0;

      metrics.push({
        nodeName,
        nodeType,
        totalExecutions,
        successfulExecutions,
        failedExecutions,
        avgDurationMs,
        errorRate,
      });
    }

    return metrics.sort((a, b) => b.totalExecutions - a.totalExecutions);
  }

  /**
   * Get recent workflow runs with details
   */
  async getRecentWorkflowRuns(options: {
    workflowName?: string;
    userId?: string;
    analysisId?: string;
    limit?: number;
    status?: 'running' | 'completed' | 'failed';
  }): Promise<Array<{
    id: string;
    workflowType: string;
    status: string;
    startedAt: Date;
    completedAt: Date | null;
    durationMs: number | null;
    errorMessage: string | null;
    userId: string | null;
    analysisId: string | null;
    jobId: string | null;
    tags: string[];
  }>> {
    const where: any = {};

    if (options.workflowName) {
      where.workflowName = options.workflowName;
    }

    if (options.userId) {
      where.userId = options.userId;
    }

    if (options.analysisId) {
      where.analysisId = options.analysisId;
    }

    if (options.status) {
      where.status = options.status;
    }

    const runs = await this.prisma.workflowRun.findMany({
      where,
      orderBy: { startedAt: 'desc' },
      take: options.limit || 50,
      select: {
        id: true,
        workflowType: true,
        status: true,
        startedAt: true,
        completedAt: true,
        durationMs: true,
        errorMessage: true,
        userId: true,
        analysisId: true,
        jobId: true,
        tags: true,
      },
    });

    return runs;
  }

  /**
   * Get workflow execution timeline (events for a specific run)
   */
  async getWorkflowTimeline(workflowRunId: string): Promise<{
    workflowRun: {
      id: string;
      workflowType: string;
      status: string;
      startedAt: Date;
      completedAt: Date | null;
      durationMs: number | null;
    };
    events: Array<{
      id: string;
      eventType: string;
      nodeName: string;
      nodeType: string;
      timestamp: Date;
      durationMs: number | null;
      errorMessage: string | null;
    }>;
  }> {
    const workflowRun = await this.prisma.workflowRun.findUnique({
      where: { id: workflowRunId },
      select: {
        id: true,
        workflowType: true,
        status: true,
        startedAt: true,
        completedAt: true,
        durationMs: true,
      },
    });

    if (!workflowRun) {
      throw new Error(`Workflow run ${workflowRunId} not found`);
    }

    const events = await this.prisma.workflowEvent.findMany({
      where: { workflowRunId },
      orderBy: { timestamp: 'asc' },
      select: {
        id: true,
        eventType: true,
        nodeName: true,
        nodeType: true,
        timestamp: true,
        durationMs: true,
        errorMessage: true,
      },
    });

    return {
      workflowRun,
      events: events.map(e => ({
        ...e,
        timestamp: e.timestamp,
      })),
    };
  }

  /**
   * Get workflow error summary (grouped by error type)
   */
  async getWorkflowErrors(options: {
    workflowName?: string;
    hours?: number;
    limit?: number;
  }): Promise<Array<{
    errorName: string;
    errorMessage: string;
    count: number;
    firstOccurrence: Date;
    lastOccurrence: Date;
    workflowRunIds: string[];
  }>> {
    const since = new Date(Date.now() - (options.hours || 24) * 60 * 60 * 1000);

    const where: any = {
      status: 'failed',
      startedAt: { gte: since },
    };

    if (options.workflowName) {
      where.workflowName = options.workflowName;
    }

    const failedRuns = await this.prisma.workflowRun.findMany({
      where,
      select: {
        id: true,
        errorName: true,
        errorMessage: true,
        startedAt: true,
      },
      orderBy: { startedAt: 'desc' },
    });

    // Group by error name + message
    const errorGroups = new Map<string, typeof failedRuns>();
    for (const run of failedRuns) {
      const key = `${run.errorName}:${run.errorMessage}`;
      if (!errorGroups.has(key)) {
        errorGroups.set(key, []);
      }
      errorGroups.get(key)!.push(run);
    }

    // Build error summary
    const errorSummary = [];
    for (const [key, runs] of errorGroups.entries()) {
      const [errorName, errorMessage] = key.split(':');
      const timestamps = runs.map(r => r.startedAt).sort((a, b) => a.getTime() - b.getTime());

      errorSummary.push({
        errorName: errorName || 'Unknown',
        errorMessage: errorMessage || 'No message',
        count: runs.length,
        firstOccurrence: timestamps[0],
        lastOccurrence: timestamps[timestamps.length - 1],
        workflowRunIds: runs.map(r => r.id),
      });
    }

    return errorSummary
      .sort((a, b) => b.count - a.count)
      .slice(0, options.limit || 20);
  }

  /**
   * Get workflow health status
   */
  async getWorkflowHealth(workflowName?: string): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    errorRate: number;
    successRate: number;
    avgDurationMs: number | null;
    runningCount: number;
    recentFailures: number;
    recommendation: string;
  }> {
    const metrics = await this.getWorkflowMetrics({
      workflowName,
      hours: 1, // Last hour
    });

    const recentRuns = await this.getRecentWorkflowRuns({
      workflowName,
      limit: 10,
    });

    const recentFailures = recentRuns.filter(r => r.status === 'failed').length;

    // Determine health status
    let status: 'healthy' | 'degraded' | 'unhealthy';
    let recommendation: string;

    if (metrics.errorRate >= 50) {
      status = 'unhealthy';
      recommendation = 'High error rate detected. Investigate recent failures immediately.';
    } else if (metrics.errorRate >= 20 || metrics.runningRuns >= 10) {
      status = 'degraded';
      recommendation = 'Elevated error rate or high number of running workflows. Monitor closely.';
    } else {
      status = 'healthy';
      recommendation = 'Workflow is operating normally.';
    }

    return {
      status,
      errorRate: metrics.errorRate,
      successRate: metrics.successRate,
      avgDurationMs: metrics.avgDurationMs,
      runningCount: metrics.runningRuns,
      recentFailures,
      recommendation,
    };
  }
}
